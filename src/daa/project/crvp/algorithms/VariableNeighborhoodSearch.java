package daa.project.crvp.algorithms;

import daa.project.crvp.local_search.LocalSearch;
import daa.project.crvp.metrics.AlgorithmRecorder;
import daa.project.crvp.moves.Move;
import daa.project.crvp.problem.CVRPSolution;
import daa.project.crvp.utils.DoubleCompare;

/**
 * Variable Neighborhood Search implementation
 * 
 * @author Carlos Dominguez Garcia (alu0100966589)
 * @version 1.0.0
 * @since 1.0.0 (May 1, 2018)
 * @file VariableNeighborhoodSearch.java
 *
 */
public class VariableNeighborhoodSearch {
    /** Probability to stop the shaking phase of iterating over the neighbors */
    static final double SHAKING_STOP_PROBABILITY = 0.01;
    
    /**
     * Run the VNS algorithm over the initial solution provided, using the local search provided
     * and using the moves provided for the shaking phase
     * 
     * @param initialSolution   Initial solution to improve using VNS
     * @param moves List of moves to use for the shaking phase
     * @param localSearch   Local search to use to find a local optimum
     * @return  The local optimum generated by the VNS
     */
    public static CVRPSolution run(CVRPSolution initialSolution, Move[] moves, LocalSearch localSearch,
            int maxNumIterationsNoImprovement, AlgorithmRecorder recorder) {
        if (moves.length < 1) {
            throw new IllegalArgumentException("invalid list of moves for VNS");
        }
        if (!initialSolution.isFeasible()) {
            throw new IllegalArgumentException("initial solution for VNS is not feasible");
        }
        
        recorder.starting();
        CVRPSolution bestSolutionFoundSoFar = initialSolution;
        CVRPSolution currentSolution = initialSolution;
        recorder.foundBetterSolution(bestSolutionFoundSoFar);
        
        int numIterationsWithNoImprovement = 0;
        while (numIterationsWithNoImprovement < maxNumIterationsNoImprovement) {
            recorder.aboutToDoNextIteration();
            int currentMoveIndex = 0;
            while (currentMoveIndex < moves.length) {
                // Make a random move in the neighborhood to try to get out of the local optimum
                CVRPSolution shakedSolution = shakeSolution(currentSolution, moves[currentMoveIndex]);
                
                if (!shakedSolution.isFeasible()) {
                    System.err.println("Current move index" + currentMoveIndex);
                }
                
                // Find a optimum from the shaked solution to see if we get to a better local optimum
                CVRPSolution currentOptimum = localSearch.findLocalOptimum(shakedSolution);
                
                // If the new solution is better -> reset the neighborhood structure to the first
                // one for the next iterations and update the current best solution found
                if (DoubleCompare.lessThan(currentOptimum.getTotalDistance(),
                        bestSolutionFoundSoFar.getTotalDistance())) {
                    bestSolutionFoundSoFar = currentOptimum;
                    currentMoveIndex = 0;
                    numIterationsWithNoImprovement = 0;
                    recorder.foundBetterSolution(bestSolutionFoundSoFar);
                } else {
                    currentMoveIndex += 1;
                }
            }
            numIterationsWithNoImprovement += 1;
        }
        
        recorder.finishing();
        return bestSolutionFoundSoFar;
    }
    
    /**
     * Shaking phase of the VNS. The goal is to return a random neighbor in the given
     * neighborhood structure. This is to hopefully escape from the current local optimum
     * and later, using a local search reaching a better local optimum
     * 
     * @param solutionToShake   Solution from which we'll search a random neighbor
     * @param move  Move that generates the neighborhood structure where we have to look for the random neighbor
     * @return  A random neighbor of the given solution
     */
    static CVRPSolution shakeSolution(CVRPSolution solutionToShake, Move move) {
        if (!solutionToShake.isFeasible()) {
            throw new IllegalArgumentException("cannot perform shaking phase of VNS on an unfeasible solution");
        }
        move.setSolution(solutionToShake);
        while (move.hasMoreNeighbors()) {
            // "Throw a dice" to see whether we take the current solution or not
            if (move.isCurrentNeighborFeasible() && DoubleCompare.lessThan(Math.random(), SHAKING_STOP_PROBABILITY)) {
                return move.getCurrentNeighbor();
            }
            // Update move to the next neighbor
            move.nextNeighbor();
            // Skip not feasible solutions
            while (move.hasMoreNeighbors() && !move.isCurrentNeighborFeasible()) {
                move.nextNeighbor();
            }
        }
        return move.isCurrentNeighborFeasible() ? move.getCurrentNeighbor() : solutionToShake;
    }
    
}
